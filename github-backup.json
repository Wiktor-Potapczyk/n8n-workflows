{
  "updatedAt": "2026-01-25T22:49:22.089Z",
  "createdAt": "2026-01-25T21:17:23.654Z",
  "id": "7CYMwhpzDbdxJsTc",
  "name": "GitHub Backup",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "options": {}
      },
      "id": "REDACTED-UUID",
      "name": "Set date",
      "type": "n8n-nodes-base.dateTime",
      "typeVersion": 2,
      "position": [
        48,
        16
      ]
    },
    {
      "parameters": {
        "operation": "formatDate",
        "date": "={{ $json.currentDate }}",
        "format": "custom",
        "customFormat": "dd-MM-yyyy/H:mm",
        "options": {}
      },
      "id": "REDACTED-UUID",
      "name": "Format date",
      "type": "n8n-nodes-base.dateTime",
      "typeVersion": 2,
      "position": [
        272,
        16
      ]
    },
    {
      "parameters": {
        "keepOnlySet": true,
        "values": {
          "string": [
            {
              "name": "commitDate",
              "value": "={{ $json.formattedDate }}"
            }
          ]
        },
        "options": {}
      },
      "id": "REDACTED-UUID",
      "name": "Set commit date",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [
        496,
        16
      ]
    },
    {
      "parameters": {
        "authentication": "REDACTED",
        "resource": "file",
        "operation": "list",
        "owner": {
          "__rl": true,
          "value": "Wiktor-Potapczyk",
          "mode": "list",
          "cachedResultName": {
            "_redacted": true
          },
          "cachedResultUrl": {
            "_redacted": true
          }
        },
        "repository": {
          "__rl": true,
          "value": "n8n-workflows",
          "mode": "list",
          "cachedResultName": {
            "_redacted": true
          },
          "cachedResultUrl": {
            "_redacted": true
          }
        },
        "filePath": "="
      },
      "id": "REDACTED-UUID",
      "name": "List files from repository [GITHUB]",
      "type": "n8n-nodes-base.github",
      "typeVersion": 1,
      "position": [
        720,
        16
      ],
      "alwaysOutputData": true,
      "webhookId": {
        "_redacted": true
      },
      "credentials": {
        "_redacted": true
      }
    },
    {
      "parameters": {
        "operation": "aggregateItems",
        "fieldsToAggregate": {
          "fieldToAggregate": [
            {
              "fieldToAggregate": "name"
            }
          ]
        },
        "options": {}
      },
      "id": "REDACTED-UUID",
      "name": "Combine file names [GITHUB]",
      "type": "n8n-nodes-base.itemLists",
      "typeVersion": 2.1,
      "position": [
        944,
        16
      ]
    },
    {
      "parameters": {
        "filters": {
          "projectId": {
            "_redacted": true
          }
        },
        "requestOptions": {}
      },
      "id": "REDACTED-UUID",
      "name": "Retrieve workflows [N8N]",
      "type": "n8n-nodes-base.n8n",
      "typeVersion": 1,
      "position": [
        1168,
        16
      ],
      "credentials": {
        "_redacted": true
      }
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "REDACTED-UUID",
      "name": "Split to single items",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 2,
      "position": [
        1600,
        16
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $node['Combine file names [GITHUB]'].json.name }}",
              "operation": "contains",
              "value2": "={{ $json.name.replace(/[^a-zA-Z0-9]/g, '-').replace(/-+/g, '-').toLowerCase() }}.json"
            }
          ]
        }
      },
      "id": "REDACTED-UUID",
      "name": "Check if file exists in repository",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        1840,
        0
      ]
    },
    {
      "parameters": {
        "authentication": "REDACTED",
        "resource": "file",
        "operation": "edit",
        "owner": {
          "__rl": true,
          "value": "Wiktor-Potapczyk",
          "mode": "list",
          "cachedResultName": {
            "_redacted": true
          },
          "cachedResultUrl": {
            "_redacted": true
          }
        },
        "repository": {
          "__rl": true,
          "value": "n8n-workflows",
          "mode": "list",
          "cachedResultName": {
            "_redacted": true
          },
          "cachedResultUrl": {
            "_redacted": true
          }
        },
        "filePath": "={{ $json.name.replace(/[^a-zA-Z0-9]/g, '-').replace(/-+/g, '-').toLowerCase() }}.json",
        "fileContent": "={{ JSON.stringify($json, null, 2) }}",
        "commitMessage": "={{ $('Basic LLM Chain').item.json.text }}"
      },
      "id": "REDACTED-UUID",
      "name": "Update file [GITHUB]",
      "type": "n8n-nodes-base.github",
      "typeVersion": 1,
      "position": [
        4192,
        352
      ],
      "webhookId": {
        "_redacted": true
      },
      "credentials": {
        "_redacted": true
      }
    },
    {
      "parameters": {
        "authentication": "REDACTED",
        "resource": "file",
        "owner": {
          "__rl": true,
          "value": "Wiktor-Potapczyk",
          "mode": "list",
          "cachedResultName": {
            "_redacted": true
          },
          "cachedResultUrl": {
            "_redacted": true
          }
        },
        "repository": {
          "__rl": true,
          "value": "n8n-workflows",
          "mode": "list",
          "cachedResultName": {
            "_redacted": true
          },
          "cachedResultUrl": {
            "_redacted": true
          }
        },
        "filePath": "={{ $json.name.replace(/[^a-zA-Z0-9]/g, '-').replace(/-+/g, '-').toLowerCase() }}.json",
        "fileContent": "={{ JSON.stringify($json, null, 2) }}",
        "commitMessage": "=created {{ $json.name }} ({{ $node['Set commit date'].json.commitDate }})"
      },
      "id": "REDACTED-UUID",
      "name": "Upload file [GITHUB]",
      "type": "n8n-nodes-base.github",
      "typeVersion": 1,
      "position": [
        2656,
        192
      ],
      "webhookId": {
        "_redacted": true
      },
      "credentials": {
        "_redacted": true
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [
        -176,
        16
      ],
      "id": "REDACTED-UUID",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "authentication": "REDACTED",
        "resource": "file",
        "operation": "get",
        "owner": {
          "__rl": true,
          "value": "Wiktor-Potapczyk",
          "mode": "list",
          "cachedResultName": {
            "_redacted": true
          },
          "cachedResultUrl": {
            "_redacted": true
          }
        },
        "repository": {
          "__rl": true,
          "value": "n8n-workflows",
          "mode": "list",
          "cachedResultName": {
            "_redacted": true
          },
          "cachedResultUrl": {
            "_redacted": true
          }
        },
        "filePath": "={{ $json.name.replace(/[^a-zA-Z0-9]/g, '-').replace(/-+/g, '-').toLowerCase() }}.json",
        "additionalParameters": {}
      },
      "type": "n8n-nodes-base.github",
      "typeVersion": 1.1,
      "position": [
        2048,
        -96
      ],
      "id": "REDACTED-UUID",
      "name": "Get a file",
      "webhookId": {
        "_redacted": true
      },
      "credentials": {
        "_redacted": true
      }
    },
    {
      "parameters": {
        "operation": "fromJson",
        "options": {}
      },
      "type": "REDACTED-POSSIBLE-SECRET",
      "typeVersion": 1.1,
      "position": [
        2256,
        -96
      ],
      "id": "REDACTED-UUID",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "REDACTED-UUID",
              "name": "repo",
              "value": "={{ $json.data }}",
              "type": "object"
            },
            {
              "id": "REDACTED-UUID",
              "name": "new",
              "value": "={{ $('Split to single items').item.json }}",
              "type": "object"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2448,
        -96
      ],
      "id": "REDACTED-UUID",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Write a semantic commit message for these workflow changes.\n\nFormat: type(scope): description\n- Types: feat (new feature), fix (bug fix), refactor (code improvement), chore (maintenance)\n- Scope: node name or \"workflow\" (use short form, e.g. \"code\" not \"Code in JavaScript\")\n- Max 60 characters total\n- Output ONLY the commit message, nothing else\n- No quotes, no markdown, no explanation\n\nExamples:\n- feat(code): add CV type detection based on job title\n- fix(sheets): correct column mapping for job data\n- feat(workflow): add response timestamp node\n- refactor(code): simplify row matching logic\n\n### WORKFLOW: {{ $json.workflowName }}\n\n### CHANGES:\n{{ $json.summary }}",
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.9,
      "position": [
        3168,
        -96
      ],
      "id": "REDACTED-UUID",
      "name": "Basic LLM Chain"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "REDACTED-POSSIBLE-SECRET",
      "typeVersion": 1,
      "position": [
        3168,
        64
      ],
      "id": "REDACTED-UUID",
      "name": "DeepSeek Chat Model",
      "credentials": {
        "_redacted": true
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Scan this n8n workflow for sensitive data. Return a JSON object with two arrays: \"paths\" and \"reasons\".\n\n### RULES FOR SCANNIG:\n1. **Header Values:** Check 'x-rapidapi-key', 'authorization', 'api-key'.\n2. **Credentials:** Check any 'credentials' object.\n3. **Meta:** Check 'meta.instanceId'.\n4. **URL Parameters:** Check for query parameters that look like secrets.\n5. **PinData (CRITICAL):** If 'pinData' exists and contains data, **DO NOT scan its contents**. Just add \"pinData\" to the paths list immediately. We want to remove the whole pinData object, not individual fields inside it.\n\n### RETURN FORMAT:\n{\n  \"paths\": [\"nodes[0].parameters.headerParameters.parameters[0].value\", \"pinData\", \"meta.instanceId\"],\n  \"reasons\": [\"RapidAPI Key\", \"User execution data (entire object)\", \"Instance ID\"]\n}\n\nWORKFLOW:\n{{ JSON.stringify($('Edit Fields').item.json.new) }}",
        "hasOutputParser": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.9,
      "position": [
        3520,
        -96
      ],
      "id": "REDACTED-UUID",
      "name": "Basic LLM Chain1",
      "retryOnFail": true
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "REDACTED-POSSIBLE-SECRET",
      "typeVersion": 1,
      "position": [
        3520,
        64
      ],
      "id": "REDACTED-UUID",
      "name": "DeepSeek Chat Model1",
      "credentials": {
        "_redacted": true
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"paths\": {\n      \"type\": \"array\",\n      \"description\": \"List of JSON paths to redact. If a whole object (like 'pinData') is sensitive, list only the root key, do not list children.\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"reasons\": {\n      \"type\": \"array\",\n      \"description\": \"Short explanation for each path.\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    }\n  },\n  \"required\": [\n    \"paths\",\n    \"reasons\"\n  ]\n}"
      },
      "type": "REDACTED-POSSIBLE-SECRET",
      "typeVersion": 1.3,
      "position": [
        3664,
        64
      ],
      "id": "REDACTED-UUID",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Scan this n8n workflow for sensitive data. Return a JSON object with two arrays: \"paths\" and \"reasons\".\n\n### RULES FOR SCANNIG:\n1. **Header Values:** Check 'x-rapidapi-key', 'authorization', 'api-key'.\n2. **Credentials:** Check any 'credentials' object.\n3. **Meta:** Check 'meta.instanceId'.\n4. **URL Parameters:** Check for query parameters that look like secrets.\n5. **PinData (CRITICAL):** If 'pinData' exists and contains data, **DO NOT scan its contents**. Just add \"pinData\" to the paths list immediately. We want to remove the whole pinData object, not individual fields inside it.\n\n### RETURN FORMAT:\n{\n  \"paths\": [\"nodes[0].parameters.headerParameters.parameters[0].value\", \"pinData\", \"meta.instanceId\"],\n  \"reasons\": [\"RapidAPI Key\", \"User execution data (entire object)\", \"Instance ID\"]\n}\n\nWORKFLOW:\n{{ JSON.stringify($json) }}",
        "hasOutputParser": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.9,
      "position": [
        2080,
        192
      ],
      "id": "REDACTED-UUID",
      "name": "Basic LLM Chain2"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "REDACTED-POSSIBLE-SECRET",
      "typeVersion": 1,
      "position": [
        2080,
        352
      ],
      "id": "REDACTED-UUID",
      "name": "DeepSeek Chat Model2",
      "credentials": {
        "_redacted": true
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"paths\": {\n      \"type\": \"array\",\n      \"description\": \"List of JSON paths to redact. If a whole object (like 'pinData') is sensitive, list only the root key, do not list children.\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"reasons\": {\n      \"type\": \"array\",\n      \"description\": \"Short explanation for each path.\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    }\n  },\n  \"required\": [\n    \"paths\",\n    \"reasons\"\n  ]\n}"
      },
      "type": "REDACTED-POSSIBLE-SECRET",
      "typeVersion": 1.3,
      "position": [
        2224,
        352
      ],
      "id": "REDACTED-UUID",
      "name": "Structured Output Parser1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "REDACTED-UUID",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        2864,
        -96
      ],
      "id": "REDACTED-UUID",
      "name": "If"
    },
    {
      "parameters": {
        "authentication": "REDACTED",
        "resource": "file",
        "operation": "edit",
        "owner": {
          "__rl": true,
          "value": "Wiktor-Potapczyk",
          "mode": "list",
          "cachedResultName": {
            "_redacted": true
          },
          "cachedResultUrl": {
            "_redacted": true
          }
        },
        "repository": {
          "__rl": true,
          "value": "n8n-workflows",
          "mode": "list",
          "cachedResultName": {
            "_redacted": true
          },
          "cachedResultUrl": {
            "_redacted": true
          }
        },
        "filePath": "={{ $('New file anonymizer').item.json.name.replace(/[^a-zA-Z0-9]/g, '-').replace(/-+/g, '-').toLowerCase() }}.json",
        "fileContent": "={{ JSON.stringify($('New file anonymizer').item.json, null, 2) }}",
        "commitMessage": "=edited {{ $('New file anonymizer').item.json.name }} ({{ $node['Set commit date'].json.commitDate }})"
      },
      "id": "REDACTED-UUID",
      "name": "Upload file [GITHUB]1",
      "type": "n8n-nodes-base.github",
      "typeVersion": 1,
      "position": [
        2944,
        208
      ],
      "webhookId": {
        "_redacted": true
      },
      "credentials": {
        "_redacted": true
      }
    },
    {
      "parameters": {
        "jsCode": "// 1. POBIERANIE DANYCH (콐cie콮ka CREATE)\n// Bierzemy g켹칩wny obiekt z inputu p캧tli\nconst workflow = $('Split to single items').first().json;\n\nconst sanitized = JSON.parse(JSON.stringify(workflow));\n\n// ==========================================\\n// 游 CONFIGURATION\\n// ==========================================\\n\nconst SENSITIVE_KEY_NAMES = [\n  /api[-_]?key/i, /secret/i, /token/i, /password/i, /passwd/i,\n  /bearer/i, /authorization/i, /auth/i, /credential/i,\n  /rapidapi/i, /openai/i, /anthropic/i, /deepseek/i,\n  /private[-_]?key/i, /access[-_]?key/i, /client[-_]?secret/i,\n];\n\nconst SENSITIVE_VALUE_PATTERNS = [\n  { regex: /^sk-[a-zA-Z0-9]{20,}/, name: 'OpenAI' },\n  { regex: /^sk-ant-[a-zA-Z0-9-]{20,}/, name: 'Anthropic' },\n  { regex: /^xai-[a-zA-Z0-9]{20,}/, name: 'xAI' },\n  { regex: /^AIza[a-zA-Z0-9_-]{35}/, name: 'Google' },\n  { regex: /^ghp_[a-zA-Z0-9]{36}/, name: 'GitHub PAT' },\n  { regex: /^gho_[a-zA-Z0-9]{36}/, name: 'GitHub OAuth' },\n  { regex: /^xoxb-[a-zA-Z0-9-]+/, name: 'Slack Bot' },\n  { regex: /^xoxp-[a-zA-Z0-9-]+/, name: 'Slack User' },\n  { regex: /^(postgres|mysql|mongodb|redis):\\/\\/[^\\s]+/, name: 'DB Connection' },\n  { regex: /^Basic\\s+[A-Za-z0-9+/=]{10,}/, name: 'Basic Auth' },\n  { regex: /^Bearer\\s+[A-Za-z0-9._-]{10,}/, name: 'Bearer Token' },\n  { regex: /https?:\\/\\/[^:]+:[^@]+@/, name: 'URL with credentials' },\n];\n\nconst ALWAYS_REDACT_KEYS = [\n  'credentials', 'webhookId', 'cachedResultUrl', 'cachedResultName',\n  'instanceId', 'projectId', 'pinData', 'meta',\n];\n\n// ==========================================\\n// 游댢 ENTROPY DETECTION\\n// ==========================================\\n\nfunction calculateEntropy(str) {\n  if (!str || str.length < 8) return 0;\n  const freq = {};\n  for (const char of str) freq[char] = (freq[char] || 0) + 1;\n  let entropy = 0;\n  const len = str.length;\n  for (const count of Object.values(freq)) {\n    const p = count / len;\n    entropy -= p * Math.log2(p);\n  }\n  return entropy;\n}\n\nfunction looksLikeSecret(value) {\n  if (typeof value !== 'string') return false;\n  if (value.length < 16 || value.length > 200) return false;\n  for (const pattern of SENSITIVE_VALUE_PATTERNS) {\n    if (pattern.regex.test(value)) return true;\n  }\n  const entropy = calculateEntropy(value);\n  const hasNumbers = /\\d/.test(value);\n  const hasLetters = /[a-zA-Z]/.test(value);\n  const noSpaces = !/\\s/.test(value);\n  const longEnough = value.length >= 20;\n  if (entropy > 4.0 && hasNumbers && hasLetters && noSpaces && longEnough) {\n    return true;\n  }\n  return false;\n}\n\nfunction isSensitiveKeyName(name) {\n  if (typeof name !== 'string') return false;\n  return SENSITIVE_KEY_NAMES.some(pattern => pattern.test(name));\n}\n\n// ==========================================\\n// 游댢 SANITIZATION\\n// ==========================================\\n\nfunction sanitizeValue(value, keyPath) {\n  if (typeof value !== 'string') return value;\n  const uuidRegex = /[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/gi;\n  if (uuidRegex.test(value)) return value.replace(uuidRegex, 'REDACTED-UUID');\n  \n  const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g;\n  if (emailRegex.test(value)) return value.replace(emailRegex, 'REDACTED@email.com');\n  \n  if (value.includes('docs.google.com') || value.includes('sheets.google.com')) {\n    return value.replace(/\\/d\\/[a-zA-Z0-9_-]+/, '/d/REDACTED-DOC-ID');\n  }\n  \n  if (value.includes('/webhook/')) {\n    return value.replace(/\\/webhook\\/[a-f0-9-]+/gi, '/webhook/REDACTED');\n  }\n  \n  if (looksLikeSecret(value)) return 'REDACTED-POSSIBLE-SECRET';\n  \n  return value;\n}\n\nfunction sanitizeObject(obj, path = '') {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj === 'string') return sanitizeValue(obj, path);\n  if (Array.isArray(obj)) return obj.map((item, i) => sanitizeObject(item, `${path}[${i}]`));\n  \n  if (typeof obj === 'object') {\n    const result = {};\n    if (obj.name && obj.value !== undefined) {\n      if (isSensitiveKeyName(obj.name)) return { ...obj, value: 'REDACTED-API-KEY' };\n      if (looksLikeSecret(obj.value)) return { ...obj, value: 'REDACTED-POSSIBLE-SECRET' };\n    }\n    const keyField = obj.key || obj.header || obj.param;\n    const valueField = obj.value || obj.content || obj.val;\n    if (keyField && valueField) {\n      if (isSensitiveKeyName(keyField) || looksLikeSecret(valueField)) {\n        return { ...obj, [Object.keys(obj).find(k => ['value', 'content', 'val'].includes(k))]: 'REDACTED' };\n      }\n    }\n    for (const [key, value] of Object.entries(obj)) {\n      const currentPath = path ? `${path}.${key}` : key;\n      if (ALWAYS_REDACT_KEYS.includes(key)) {\n        result[key] = { \"_redacted\": true };\n        continue;\n      }\n      if (isSensitiveKeyName(key) && typeof value === 'string') {\n        result[key] = 'REDACTED';\n        continue;\n      }\n      result[key] = sanitizeObject(value, currentPath);\n    }\n    return result;\n  }\n  return obj;\n}\n\nconst anonymized = sanitizeObject(sanitized);\n\nanonymized._sanitized = {\n  note: \"Sanitized automatically\",\n  timestamp: new Date().toISOString()\n};\n\nreturn [{ json: anonymized }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2416,
        192
      ],
      "id": "REDACTED-UUID",
      "name": "New file anonymizer"
    },
    {
      "parameters": {
        "jsCode": "const oldVersion = $json.repo;\nconst newVersion = $json.new;\n\n// Klucze do ignorowania (cosmetic)\nconst IGNORE_KEYS = [\n  'position', 'id', 'webhookId', 'uuid', \n  'updatedAt', 'createdAt', 'activeVersionId',\n  'versionId', 'meta'\n];\n\n// Truncate helper\nfunction truncate(str, len) {\n  if (!str) return '';\n  str = String(str);\n  return str.length > len ? str.slice(0, len) + '...' : str;\n}\n\n// Deep compare z ignorowaniem kluczy\nfunction cleanObject(obj) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  \n  if (Array.isArray(obj)) {\n    return obj.map(item => cleanObject(item));\n  }\n  \n  const cleaned = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (IGNORE_KEYS.includes(key)) continue;\n    cleaned[key] = cleanObject(value);\n  }\n  return cleaned;\n}\n\n// Diff dla jsCode - znajd콬 dodane/usuni캧te linie\nfunction diffCode(oldCode, newCode) {\n  if (!oldCode && !newCode) return { added: [], removed: [] };\n  if (!oldCode) return { added: newCode.split('\\n').slice(0, 5), removed: [] };\n  if (!newCode) return { added: [], removed: oldCode.split('\\n').slice(0, 5) };\n  \n  const oldLines = oldCode.split('\\n').map(l => l.trim()).filter(l => l.length > 0);\n  const newLines = newCode.split('\\n').map(l => l.trim()).filter(l => l.length > 0);\n  \n  const added = newLines.filter(l => !oldLines.includes(l)).slice(0, 5);\n  const removed = oldLines.filter(l => !newLines.includes(l)).slice(0, 5);\n  \n  return { added, removed };\n}\n\n// Por칩wnaj nodes\nfunction compareNodes(oldNodes, newNodes) {\n  const changes = [];\n  \n  if (!oldNodes || !newNodes) {\n    return [{ type: 'error', detail: `Missing nodes: old=${!!oldNodes} new=${!!newNodes}` }];\n  }\n  \n  const oldByName = Object.fromEntries(oldNodes.map(n => [n.name, n]));\n  const newByName = Object.fromEntries(newNodes.map(n => [n.name, n]));\n  \n  const allNames = new Set([...Object.keys(oldByName), ...Object.keys(newByName)]);\n  \n  for (const name of allNames) {\n    if (!(name in oldByName)) {\n      const node = newByName[name];\n      changes.push({ \n        type: 'node_added', \n        node: name, \n        nodeType: node.type?.split('.').pop() || 'unknown'\n      });\n    } else if (!(name in newByName)) {\n      changes.push({ type: 'node_removed', node: name });\n    } else {\n      const oldNode = oldByName[name];\n      const newNode = newByName[name];\n      \n      const oldCode = oldNode.parameters?.jsCode;\n      const newCode = newNode.parameters?.jsCode;\n      \n      // Sprawd콬 jsCode bezpo콑rednio\n      if (oldCode !== newCode && (oldCode || newCode)) {\n        const codeDiff = diffCode(oldCode, newCode);\n        changes.push({ \n          type: 'node_modified', \n          node: name,\n          nodeType: newNode.type?.split('.').pop() || 'unknown',\n          field: 'jsCode',\n          diff: codeDiff\n        });\n        continue;\n      }\n      \n      // Sprawd콬 inne parametry\n      const oldParams = JSON.stringify(cleanObject(oldNode.parameters || {}));\n      const newParams = JSON.stringify(cleanObject(newNode.parameters || {}));\n      \n      if (oldParams !== newParams) {\n        changes.push({ \n          type: 'node_modified', \n          node: name,\n          nodeType: newNode.type?.split('.').pop() || 'unknown',\n          field: 'parameters',\n          detail: 'Config changed'\n        });\n      }\n    }\n  }\n  \n  return changes;\n}\n\n// Generuj czytelne summary\nfunction generateSummary(changes) {\n  return changes.map(c => {\n    switch(c.type) {\n      case 'node_added': \n        return `+ ADDED \"${c.node}\" (${c.nodeType})`;\n      \n      case 'node_removed': \n        return `- REMOVED \"${c.node}\"`;\n      \n      case 'node_modified': \n        let desc = `~ MODIFIED \"${c.node}\" [${c.field}]`;\n        if (c.diff) {\n          if (c.diff.added.length > 0) {\n            desc += '\\n  ADDED LINES:';\n            c.diff.added.forEach(l => desc += `\\n    + ${truncate(l, 100)}`);\n          }\n          if (c.diff.removed.length > 0) {\n            desc += '\\n  REMOVED LINES:';\n            c.diff.removed.forEach(l => desc += `\\n    - ${truncate(l, 100)}`);\n          }\n        }\n        if (c.detail) desc += `: ${c.detail}`;\n        return desc;\n      \n      case 'error':\n        return `ERROR: ${c.detail}`;\n      \n      default: \n        return `? ${c.type}`;\n    }\n  }).join('\\n\\n');\n}\n\n// === MAIN ===\nconst nodeChanges = compareNodes(oldVersion.nodes, newVersion.nodes);\n\nif (nodeChanges.length === 0) {\n  return [{ json: { \n    hasChanges: false,\n    summary: 'No significant changes detected',\n    workflowName: newVersion.name || 'unknown'\n  }}];\n}\n\nconst summary = generateSummary(nodeChanges);\n\nreturn [{ json: { \n  hasChanges: true,\n  changeCount: nodeChanges.length,\n  summary: summary,\n  workflowName: newVersion.name || 'unknown'\n}}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2656,
        -96
      ],
      "id": "REDACTED-UUID",
      "name": "Diff"
    },
    {
      "parameters": {
        "jsCode": "// 1. POBIERANIE DANYCH (콐cie콮ka UPDATE)\n// Bierzemy \"new\" z aktualnego inputu p캧tli\nconst workflow = $('Edit Fields').first().json.new;\n\n// Je콑li z jakiego콑 powodu jest pusto, fallback do czystego jsona\n// const workflow = inputData.new || inputData;\n\nconst sanitized = JSON.parse(JSON.stringify(workflow));\n\n// ==========================================\\n// 游 CONFIGURATION\\n// ==========================================\\n\n// Nazwy kluczy kt칩re ZAWSZE redagujemy (case-insensitive)\nconst SENSITIVE_KEY_NAMES = [\n  /api[-_]?key/i, /secret/i, /token/i, /password/i, /passwd/i,\n  /bearer/i, /authorization/i, /auth/i, /credential/i,\n  /rapidapi/i, /openai/i, /anthropic/i, /deepseek/i,\n  /private[-_]?key/i, /access[-_]?key/i, /client[-_]?secret/i,\n];\n\n// Wzorce warto콑ci kt칩re ZAWSZE redagujemy\nconst SENSITIVE_VALUE_PATTERNS = [\n  { regex: /^sk-[a-zA-Z0-9]{20,}/, name: 'OpenAI' },\n  { regex: /^sk-ant-[a-zA-Z0-9-]{20,}/, name: 'Anthropic' },\n  { regex: /^xai-[a-zA-Z0-9]{20,}/, name: 'xAI' },\n  { regex: /^AIza[a-zA-Z0-9_-]{35}/, name: 'Google' },\n  { regex: /^ghp_[a-zA-Z0-9]{36}/, name: 'GitHub PAT' },\n  { regex: /^gho_[a-zA-Z0-9]{36}/, name: 'GitHub OAuth' },\n  { regex: /^xoxb-[a-zA-Z0-9-]+/, name: 'Slack Bot' },\n  { regex: /^xoxp-[a-zA-Z0-9-]+/, name: 'Slack User' },\n  { regex: /^(postgres|mysql|mongodb|redis):\\/\\/[^\\s]+/, name: 'DB Connection' },\n  { regex: /^Basic\\s+[A-Za-z0-9+/=]{10,}/, name: 'Basic Auth' },\n  { regex: /^Bearer\\s+[A-Za-z0-9._-]{10,}/, name: 'Bearer Token' },\n  { regex: /https?:\\/\\/[^:]+:[^@]+@/, name: 'URL with credentials' },\n];\n\n// Klucze do ca켹kowitego usuni캧cia\nconst ALWAYS_REDACT_KEYS = [\n  'credentials', 'webhookId', 'cachedResultUrl', 'cachedResultName',\n  'instanceId', 'projectId', 'pinData', 'meta',\n];\n\n// ==========================================\\n// 游댢 ENTROPY DETECTION\\n// ==========================================\\n\nfunction calculateEntropy(str) {\n  if (!str || str.length < 8) return 0;\n  const freq = {};\n  for (const char of str) freq[char] = (freq[char] || 0) + 1;\n  let entropy = 0;\n  const len = str.length;\n  for (const count of Object.values(freq)) {\n    const p = count / len;\n    entropy -= p * Math.log2(p);\n  }\n  return entropy;\n}\n\nfunction looksLikeSecret(value) {\n  if (typeof value !== 'string') return false;\n  if (value.length < 16 || value.length > 200) return false;\n  for (const pattern of SENSITIVE_VALUE_PATTERNS) {\n    if (pattern.regex.test(value)) return true;\n  }\n  const entropy = calculateEntropy(value);\n  const hasNumbers = /\\d/.test(value);\n  const hasLetters = /[a-zA-Z]/.test(value);\n  const noSpaces = !/\\s/.test(value);\n  const longEnough = value.length >= 20;\n  if (entropy > 4.0 && hasNumbers && hasLetters && noSpaces && longEnough) {\n    return true;\n  }\n  return false;\n}\n\nfunction isSensitiveKeyName(name) {\n  if (typeof name !== 'string') return false;\n  return SENSITIVE_KEY_NAMES.some(pattern => pattern.test(name));\n}\n\n// ==========================================\\n// 游댢 SANITIZATION\\n// ==========================================\\n\nconst redactedLog = [];\n\nfunction sanitizeValue(value, keyPath) {\n  if (typeof value !== 'string') return value;\n  const uuidRegex = /[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/gi;\n  if (uuidRegex.test(value)) return value.replace(uuidRegex, 'REDACTED-UUID');\n  \n  const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g;\n  if (emailRegex.test(value)) return value.replace(emailRegex, 'REDACTED@email.com');\n  \n  if (value.includes('docs.google.com') || value.includes('sheets.google.com')) {\n    return value.replace(/\\/d\\/[a-zA-Z0-9_-]+/, '/d/REDACTED-DOC-ID');\n  }\n  \n  if (value.includes('/webhook/')) {\n    return value.replace(/\\/webhook\\/[a-f0-9-]+/gi, '/webhook/REDACTED');\n  }\n  \n  if (looksLikeSecret(value)) return 'REDACTED-POSSIBLE-SECRET';\n  \n  return value;\n}\n\nfunction sanitizeObject(obj, path = '') {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj === 'string') return sanitizeValue(obj, path);\n  if (Array.isArray(obj)) return obj.map((item, i) => sanitizeObject(item, `${path}[${i}]`));\n  \n  if (typeof obj === 'object') {\n    const result = {};\n    if (obj.name && obj.value !== undefined) {\n      if (isSensitiveKeyName(obj.name)) return { ...obj, value: 'REDACTED-API-KEY' };\n      if (looksLikeSecret(obj.value)) return { ...obj, value: 'REDACTED-POSSIBLE-SECRET' };\n    }\n    const keyField = obj.key || obj.header || obj.param;\n    const valueField = obj.value || obj.content || obj.val;\n    if (keyField && valueField) {\n      if (isSensitiveKeyName(keyField) || looksLikeSecret(valueField)) {\n        return { ...obj, [Object.keys(obj).find(k => ['value', 'content', 'val'].includes(k))]: 'REDACTED' };\n      }\n    }\n    for (const [key, value] of Object.entries(obj)) {\n      const currentPath = path ? `${path}.${key}` : key;\n      if (ALWAYS_REDACT_KEYS.includes(key)) {\n        result[key] = { \"_redacted\": true };\n        continue;\n      }\n      if (isSensitiveKeyName(key) && typeof value === 'string') {\n        result[key] = 'REDACTED';\n        continue;\n      }\n      result[key] = sanitizeObject(value, currentPath);\n    }\n    return result;\n  }\n  return obj;\n}\n\nconst anonymized = sanitizeObject(sanitized);\n\n// Dodajemy metadane, 콮eby wiedzie캖 콮e zadzia켹a켹o\nanonymized._sanitized = {\n  note: \"Sanitized automatically\",\n  timestamp: new Date().toISOString()\n};\n\nreturn [{ json: anonymized }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3856,
        -96
      ],
      "id": "REDACTED-UUID",
      "name": "Existing file anonymizer"
    }
  ],
  "connections": {
    "Set date": {
      "main": [
        [
          {
            "node": "Format date",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format date": {
      "main": [
        [
          {
            "node": "Set commit date",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set commit date": {
      "main": [
        [
          {
            "node": "List files from repository [GITHUB]",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List files from repository [GITHUB]": {
      "main": [
        [
          {
            "node": "Combine file names [GITHUB]",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine file names [GITHUB]": {
      "main": [
        [
          {
            "node": "Retrieve workflows [N8N]",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Retrieve workflows [N8N]": {
      "main": [
        [
          {
            "node": "Split to single items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split to single items": {
      "main": [
        [
          {
            "node": "Check if file exists in repository",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if file exists in repository": {
      "main": [
        [
          {
            "node": "Get a file",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Basic LLM Chain2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update file [GITHUB]": {
      "main": [
        [
          {
            "node": "Split to single items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload file [GITHUB]": {
      "main": [
        [
          {
            "node": "Split to single items",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Upload file [GITHUB]1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Set date",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get a file": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Diff",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain": {
      "main": [
        [
          {
            "node": "Basic LLM Chain1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DeepSeek Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain1": {
      "main": [
        [
          {
            "node": "Existing file anonymizer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DeepSeek Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Chain1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain2": {
      "main": [
        [
          {
            "node": "New file anonymizer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DeepSeek Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain2",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Chain2",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Split to single items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload file [GITHUB]1": {
      "main": [
        [
          {
            "node": "Split to single items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "New file anonymizer": {
      "main": [
        [
          {
            "node": "Upload file [GITHUB]",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Diff": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Existing file anonymizer": {
      "main": [
        [
          {
            "node": "Update file [GITHUB]",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "staticData": {
    "node:Schedule Trigger": {
      "recurrenceRules": []
    }
  },
  "meta": {
    "_redacted": true
  },
  "pinData": {
    "_redacted": true
  },
  "versionId": "REDACTED-UUID",
  "activeVersionId": "REDACTED-UUID",
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2026-01-25T21:17:23.656Z",
      "createdAt": "2026-01-25T21:17:23.656Z",
      "role": "workflow:owner",
      "workflowId": "7CYMwhpzDbdxJsTc",
      "projectId": {
        "_redacted": true
      }
    }
  ],
  "activeVersion": {
    "updatedAt": "2026-01-25T22:33:55.000Z",
    "createdAt": "2026-01-25T22:33:52.564Z",
    "versionId": "REDACTED-UUID",
    "workflowId": "7CYMwhpzDbdxJsTc",
    "nodes": [
      {
        "parameters": {
          "options": {}
        },
        "id": "REDACTED-UUID",
        "name": "Set date",
        "type": "n8n-nodes-base.dateTime",
        "typeVersion": 2,
        "position": [
          48,
          16
        ]
      },
      {
        "parameters": {
          "operation": "formatDate",
          "date": "={{ $json.currentDate }}",
          "format": "custom",
          "customFormat": "dd-MM-yyyy/H:mm",
          "options": {}
        },
        "id": "REDACTED-UUID",
        "name": "Format date",
        "type": "n8n-nodes-base.dateTime",
        "typeVersion": 2,
        "position": [
          272,
          16
        ]
      },
      {
        "parameters": {
          "keepOnlySet": true,
          "values": {
            "string": [
              {
                "name": "commitDate",
                "value": "={{ $json.formattedDate }}"
              }
            ]
          },
          "options": {}
        },
        "id": "REDACTED-UUID",
        "name": "Set commit date",
        "type": "n8n-nodes-base.set",
        "typeVersion": 2,
        "position": [
          496,
          16
        ]
      },
      {
        "parameters": {
          "authentication": "REDACTED",
          "resource": "file",
          "operation": "list",
          "owner": {
            "__rl": true,
            "value": "Wiktor-Potapczyk",
            "mode": "list",
            "cachedResultName": {
              "_redacted": true
            },
            "cachedResultUrl": {
              "_redacted": true
            }
          },
          "repository": {
            "__rl": true,
            "value": "n8n-workflows",
            "mode": "list",
            "cachedResultName": {
              "_redacted": true
            },
            "cachedResultUrl": {
              "_redacted": true
            }
          },
          "filePath": "="
        },
        "id": "REDACTED-UUID",
        "name": "List files from repository [GITHUB]",
        "type": "n8n-nodes-base.github",
        "typeVersion": 1,
        "position": [
          720,
          16
        ],
        "alwaysOutputData": true,
        "webhookId": {
          "_redacted": true
        },
        "credentials": {
          "_redacted": true
        }
      },
      {
        "parameters": {
          "operation": "aggregateItems",
          "fieldsToAggregate": {
            "fieldToAggregate": [
              {
                "fieldToAggregate": "name"
              }
            ]
          },
          "options": {}
        },
        "id": "REDACTED-UUID",
        "name": "Combine file names [GITHUB]",
        "type": "n8n-nodes-base.itemLists",
        "typeVersion": 2.1,
        "position": [
          944,
          16
        ]
      },
      {
        "parameters": {
          "filters": {
            "projectId": {
              "_redacted": true
            }
          },
          "requestOptions": {}
        },
        "id": "REDACTED-UUID",
        "name": "Retrieve workflows [N8N]",
        "type": "n8n-nodes-base.n8n",
        "typeVersion": 1,
        "position": [
          1168,
          16
        ],
        "credentials": {
          "_redacted": true
        }
      },
      {
        "parameters": {
          "batchSize": 1,
          "options": {}
        },
        "id": "REDACTED-UUID",
        "name": "Split to single items",
        "type": "n8n-nodes-base.splitInBatches",
        "typeVersion": 2,
        "position": [
          1600,
          16
        ]
      },
      {
        "parameters": {
          "conditions": {
            "string": [
              {
                "value1": "={{ $node['Combine file names [GITHUB]'].json.name }}",
                "operation": "contains",
                "value2": "={{ $json.name.replace(/[^a-zA-Z0-9]/g, '-').replace(/-+/g, '-').toLowerCase() }}.json"
              }
            ]
          }
        },
        "id": "REDACTED-UUID",
        "name": "Check if file exists in repository",
        "type": "n8n-nodes-base.if",
        "typeVersion": 1,
        "position": [
          1840,
          0
        ]
      },
      {
        "parameters": {
          "authentication": "REDACTED",
          "resource": "file",
          "operation": "edit",
          "owner": {
            "__rl": true,
            "value": "Wiktor-Potapczyk",
            "mode": "list",
            "cachedResultName": {
              "_redacted": true
            },
            "cachedResultUrl": {
              "_redacted": true
            }
          },
          "repository": {
            "__rl": true,
            "value": "n8n-workflows",
            "mode": "list",
            "cachedResultName": {
              "_redacted": true
            },
            "cachedResultUrl": {
              "_redacted": true
            }
          },
          "filePath": "={{ $json.name.replace(/[^a-zA-Z0-9]/g, '-').replace(/-+/g, '-').toLowerCase() }}.json",
          "fileContent": "={{ JSON.stringify($json, null, 2) }}",
          "commitMessage": "={{ $('Basic LLM Chain').item.json.text }}"
        },
        "id": "REDACTED-UUID",
        "name": "Update file [GITHUB]",
        "type": "n8n-nodes-base.github",
        "typeVersion": 1,
        "position": [
          4192,
          352
        ],
        "webhookId": {
          "_redacted": true
        },
        "credentials": {
          "_redacted": true
        }
      },
      {
        "parameters": {
          "authentication": "REDACTED",
          "resource": "file",
          "owner": {
            "__rl": true,
            "value": "Wiktor-Potapczyk",
            "mode": "list",
            "cachedResultName": {
              "_redacted": true
            },
            "cachedResultUrl": {
              "_redacted": true
            }
          },
          "repository": {
            "__rl": true,
            "value": "n8n-workflows",
            "mode": "list",
            "cachedResultName": {
              "_redacted": true
            },
            "cachedResultUrl": {
              "_redacted": true
            }
          },
          "filePath": "={{ $json.name.replace(/[^a-zA-Z0-9]/g, '-').replace(/-+/g, '-').toLowerCase() }}.json",
          "fileContent": "={{ JSON.stringify($json, null, 2) }}",
          "commitMessage": "=created {{ $json.name }} ({{ $node['Set commit date'].json.commitDate }})"
        },
        "id": "REDACTED-UUID",
        "name": "Upload file [GITHUB]",
        "type": "n8n-nodes-base.github",
        "typeVersion": 1,
        "position": [
          2656,
          192
        ],
        "webhookId": {
          "_redacted": true
        },
        "credentials": {
          "_redacted": true
        },
        "onError": "continueErrorOutput"
      },
      {
        "parameters": {
          "rule": {
            "interval": [
              {
                "field": "hours"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.scheduleTrigger",
        "typeVersion": 1.3,
        "position": [
          -176,
          16
        ],
        "id": "REDACTED-UUID",
        "name": "Schedule Trigger"
      },
      {
        "parameters": {
          "authentication": "REDACTED",
          "resource": "file",
          "operation": "get",
          "owner": {
            "__rl": true,
            "value": "Wiktor-Potapczyk",
            "mode": "list",
            "cachedResultName": {
              "_redacted": true
            },
            "cachedResultUrl": {
              "_redacted": true
            }
          },
          "repository": {
            "__rl": true,
            "value": "n8n-workflows",
            "mode": "list",
            "cachedResultName": {
              "_redacted": true
            },
            "cachedResultUrl": {
              "_redacted": true
            }
          },
          "filePath": "={{ $json.name.replace(/[^a-zA-Z0-9]/g, '-').replace(/-+/g, '-').toLowerCase() }}.json",
          "additionalParameters": {}
        },
        "type": "n8n-nodes-base.github",
        "typeVersion": 1.1,
        "position": [
          2048,
          -96
        ],
        "id": "REDACTED-UUID",
        "name": "Get a file",
        "webhookId": {
          "_redacted": true
        },
        "credentials": {
          "_redacted": true
        }
      },
      {
        "parameters": {
          "operation": "fromJson",
          "options": {}
        },
        "type": "REDACTED-POSSIBLE-SECRET",
        "typeVersion": 1.1,
        "position": [
          2256,
          -96
        ],
        "id": "REDACTED-UUID",
        "name": "Extract from File"
      },
      {
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "id": "REDACTED-UUID",
                "name": "repo",
                "value": "={{ $json.data }}",
                "type": "object"
              },
              {
                "id": "REDACTED-UUID",
                "name": "new",
                "value": "={{ $('Split to single items').item.json }}",
                "type": "object"
              }
            ]
          },
          "options": {}
        },
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          2448,
          -96
        ],
        "id": "REDACTED-UUID",
        "name": "Edit Fields"
      },
      {
        "parameters": {
          "promptType": "define",
          "text": "=Write a semantic commit message for these workflow changes.\n\nFormat: type(scope): description\n- Types: feat (new feature), fix (bug fix), refactor (code improvement), chore (maintenance)\n- Scope: node name or \"workflow\" (use short form, e.g. \"code\" not \"Code in JavaScript\")\n- Max 60 characters total\n- Output ONLY the commit message, nothing else\n- No quotes, no markdown, no explanation\n\nExamples:\n- feat(code): add CV type detection based on job title\n- fix(sheets): correct column mapping for job data\n- feat(workflow): add response timestamp node\n- refactor(code): simplify row matching logic\n\n### WORKFLOW: {{ $json.workflowName }}\n\n### CHANGES:\n{{ $json.summary }}",
          "batching": {}
        },
        "type": "@n8n/n8n-nodes-langchain.chainLlm",
        "typeVersion": 1.9,
        "position": [
          3168,
          -96
        ],
        "id": "REDACTED-UUID",
        "name": "Basic LLM Chain"
      },
      {
        "parameters": {
          "options": {}
        },
        "type": "REDACTED-POSSIBLE-SECRET",
        "typeVersion": 1,
        "position": [
          3168,
          64
        ],
        "id": "REDACTED-UUID",
        "name": "DeepSeek Chat Model",
        "credentials": {
          "_redacted": true
        }
      },
      {
        "parameters": {
          "promptType": "define",
          "text": "=Scan this n8n workflow for sensitive data. Return a JSON object with two arrays: \"paths\" and \"reasons\".\n\n### RULES FOR SCANNIG:\n1. **Header Values:** Check 'x-rapidapi-key', 'authorization', 'api-key'.\n2. **Credentials:** Check any 'credentials' object.\n3. **Meta:** Check 'meta.instanceId'.\n4. **URL Parameters:** Check for query parameters that look like secrets.\n5. **PinData (CRITICAL):** If 'pinData' exists and contains data, **DO NOT scan its contents**. Just add \"pinData\" to the paths list immediately. We want to remove the whole pinData object, not individual fields inside it.\n\n### RETURN FORMAT:\n{\n  \"paths\": [\"nodes[0].parameters.headerParameters.parameters[0].value\", \"pinData\", \"meta.instanceId\"],\n  \"reasons\": [\"RapidAPI Key\", \"User execution data (entire object)\", \"Instance ID\"]\n}\n\nWORKFLOW:\n{{ JSON.stringify($('Edit Fields').item.json.new) }}",
          "hasOutputParser": true,
          "batching": {}
        },
        "type": "@n8n/n8n-nodes-langchain.chainLlm",
        "typeVersion": 1.9,
        "position": [
          3520,
          -96
        ],
        "id": "REDACTED-UUID",
        "name": "Basic LLM Chain1"
      },
      {
        "parameters": {
          "options": {}
        },
        "type": "REDACTED-POSSIBLE-SECRET",
        "typeVersion": 1,
        "position": [
          3520,
          64
        ],
        "id": "REDACTED-UUID",
        "name": "DeepSeek Chat Model1",
        "credentials": {
          "_redacted": true
        }
      },
      {
        "parameters": {
          "schemaType": "manual",
          "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"paths\": {\n      \"type\": \"array\",\n      \"description\": \"List of JSON paths to redact. If a whole object (like 'pinData') is sensitive, list only the root key, do not list children.\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"reasons\": {\n      \"type\": \"array\",\n      \"description\": \"Short explanation for each path.\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    }\n  },\n  \"required\": [\n    \"paths\",\n    \"reasons\"\n  ]\n}"
        },
        "type": "REDACTED-POSSIBLE-SECRET",
        "typeVersion": 1.3,
        "position": [
          3664,
          64
        ],
        "id": "REDACTED-UUID",
        "name": "Structured Output Parser"
      },
      {
        "parameters": {
          "promptType": "define",
          "text": "=Scan this n8n workflow for sensitive data. Return a JSON object with two arrays: \"paths\" and \"reasons\".\n\n### RULES FOR SCANNIG:\n1. **Header Values:** Check 'x-rapidapi-key', 'authorization', 'api-key'.\n2. **Credentials:** Check any 'credentials' object.\n3. **Meta:** Check 'meta.instanceId'.\n4. **URL Parameters:** Check for query parameters that look like secrets.\n5. **PinData (CRITICAL):** If 'pinData' exists and contains data, **DO NOT scan its contents**. Just add \"pinData\" to the paths list immediately. We want to remove the whole pinData object, not individual fields inside it.\n\n### RETURN FORMAT:\n{\n  \"paths\": [\"nodes[0].parameters.headerParameters.parameters[0].value\", \"pinData\", \"meta.instanceId\"],\n  \"reasons\": [\"RapidAPI Key\", \"User execution data (entire object)\", \"Instance ID\"]\n}\n\nWORKFLOW:\n{{ JSON.stringify($json) }}",
          "hasOutputParser": true,
          "batching": {}
        },
        "type": "@n8n/n8n-nodes-langchain.chainLlm",
        "typeVersion": 1.9,
        "position": [
          2080,
          192
        ],
        "id": "REDACTED-UUID",
        "name": "Basic LLM Chain2"
      },
      {
        "parameters": {
          "options": {}
        },
        "type": "REDACTED-POSSIBLE-SECRET",
        "typeVersion": 1,
        "position": [
          2080,
          352
        ],
        "id": "REDACTED-UUID",
        "name": "DeepSeek Chat Model2",
        "credentials": {
          "_redacted": true
        }
      },
      {
        "parameters": {
          "schemaType": "manual",
          "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"paths\": {\n      \"type\": \"array\",\n      \"description\": \"List of JSON paths to redact. If a whole object (like 'pinData') is sensitive, list only the root key, do not list children.\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"reasons\": {\n      \"type\": \"array\",\n      \"description\": \"Short explanation for each path.\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    }\n  },\n  \"required\": [\n    \"paths\",\n    \"reasons\"\n  ]\n}"
        },
        "type": "REDACTED-POSSIBLE-SECRET",
        "typeVersion": 1.3,
        "position": [
          2224,
          352
        ],
        "id": "REDACTED-UUID",
        "name": "Structured Output Parser1"
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 3
            },
            "conditions": [
              {
                "id": "REDACTED-UUID",
                "leftValue": "={{ $json.hasChanges }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.3,
        "position": [
          2864,
          -96
        ],
        "id": "REDACTED-UUID",
        "name": "If"
      },
      {
        "parameters": {
          "authentication": "REDACTED",
          "resource": "file",
          "operation": "edit",
          "owner": {
            "__rl": true,
            "value": "Wiktor-Potapczyk",
            "mode": "list",
            "cachedResultName": {
              "_redacted": true
            },
            "cachedResultUrl": {
              "_redacted": true
            }
          },
          "repository": {
            "__rl": true,
            "value": "n8n-workflows",
            "mode": "list",
            "cachedResultName": {
              "_redacted": true
            },
            "cachedResultUrl": {
              "_redacted": true
            }
          },
          "filePath": "={{ $('New file anonymizer').item.json.name.replace(/[^a-zA-Z0-9]/g, '-').replace(/-+/g, '-').toLowerCase() }}.json",
          "fileContent": "={{ JSON.stringify($('New file anonymizer').item.json, null, 2) }}",
          "commitMessage": "=edited {{ $('New file anonymizer').item.json.name }} ({{ $node['Set commit date'].json.commitDate }})"
        },
        "id": "REDACTED-UUID",
        "name": "Upload file [GITHUB]1",
        "type": "n8n-nodes-base.github",
        "typeVersion": 1,
        "position": [
          2944,
          208
        ],
        "webhookId": {
          "_redacted": true
        },
        "credentials": {
          "_redacted": true
        }
      },
      {
        "parameters": {
          "jsCode": "// 1. POBIERANIE DANYCH (콐cie콮ka CREATE)\n// Bierzemy g켹칩wny obiekt z inputu p캧tli\nconst workflow = $('Split to single items').first().json;\n\nconst sanitized = JSON.parse(JSON.stringify(workflow));\n\n// ==========================================\\n// 游 CONFIGURATION\\n// ==========================================\\n\nconst SENSITIVE_KEY_NAMES = [\n  /api[-_]?key/i, /secret/i, /token/i, /password/i, /passwd/i,\n  /bearer/i, /authorization/i, /auth/i, /credential/i,\n  /rapidapi/i, /openai/i, /anthropic/i, /deepseek/i,\n  /private[-_]?key/i, /access[-_]?key/i, /client[-_]?secret/i,\n];\n\nconst SENSITIVE_VALUE_PATTERNS = [\n  { regex: /^sk-[a-zA-Z0-9]{20,}/, name: 'OpenAI' },\n  { regex: /^sk-ant-[a-zA-Z0-9-]{20,}/, name: 'Anthropic' },\n  { regex: /^xai-[a-zA-Z0-9]{20,}/, name: 'xAI' },\n  { regex: /^AIza[a-zA-Z0-9_-]{35}/, name: 'Google' },\n  { regex: /^ghp_[a-zA-Z0-9]{36}/, name: 'GitHub PAT' },\n  { regex: /^gho_[a-zA-Z0-9]{36}/, name: 'GitHub OAuth' },\n  { regex: /^xoxb-[a-zA-Z0-9-]+/, name: 'Slack Bot' },\n  { regex: /^xoxp-[a-zA-Z0-9-]+/, name: 'Slack User' },\n  { regex: /^(postgres|mysql|mongodb|redis):\\/\\/[^\\s]+/, name: 'DB Connection' },\n  { regex: /^Basic\\s+[A-Za-z0-9+/=]{10,}/, name: 'Basic Auth' },\n  { regex: /^Bearer\\s+[A-Za-z0-9._-]{10,}/, name: 'Bearer Token' },\n  { regex: /https?:\\/\\/[^:]+:[^@]+@/, name: 'URL with credentials' },\n];\n\nconst ALWAYS_REDACT_KEYS = [\n  'credentials', 'webhookId', 'cachedResultUrl', 'cachedResultName',\n  'instanceId', 'projectId', 'pinData', 'meta',\n];\n\n// ==========================================\\n// 游댢 ENTROPY DETECTION\\n// ==========================================\\n\nfunction calculateEntropy(str) {\n  if (!str || str.length < 8) return 0;\n  const freq = {};\n  for (const char of str) freq[char] = (freq[char] || 0) + 1;\n  let entropy = 0;\n  const len = str.length;\n  for (const count of Object.values(freq)) {\n    const p = count / len;\n    entropy -= p * Math.log2(p);\n  }\n  return entropy;\n}\n\nfunction looksLikeSecret(value) {\n  if (typeof value !== 'string') return false;\n  if (value.length < 16 || value.length > 200) return false;\n  for (const pattern of SENSITIVE_VALUE_PATTERNS) {\n    if (pattern.regex.test(value)) return true;\n  }\n  const entropy = calculateEntropy(value);\n  const hasNumbers = /\\d/.test(value);\n  const hasLetters = /[a-zA-Z]/.test(value);\n  const noSpaces = !/\\s/.test(value);\n  const longEnough = value.length >= 20;\n  if (entropy > 4.0 && hasNumbers && hasLetters && noSpaces && longEnough) {\n    return true;\n  }\n  return false;\n}\n\nfunction isSensitiveKeyName(name) {\n  if (typeof name !== 'string') return false;\n  return SENSITIVE_KEY_NAMES.some(pattern => pattern.test(name));\n}\n\n// ==========================================\\n// 游댢 SANITIZATION\\n// ==========================================\\n\nfunction sanitizeValue(value, keyPath) {\n  if (typeof value !== 'string') return value;\n  const uuidRegex = /[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/gi;\n  if (uuidRegex.test(value)) return value.replace(uuidRegex, 'REDACTED-UUID');\n  \n  const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g;\n  if (emailRegex.test(value)) return value.replace(emailRegex, 'REDACTED@email.com');\n  \n  if (value.includes('docs.google.com') || value.includes('sheets.google.com')) {\n    return value.replace(/\\/d\\/[a-zA-Z0-9_-]+/, '/d/REDACTED-DOC-ID');\n  }\n  \n  if (value.includes('/webhook/')) {\n    return value.replace(/\\/webhook\\/[a-f0-9-]+/gi, '/webhook/REDACTED');\n  }\n  \n  if (looksLikeSecret(value)) return 'REDACTED-POSSIBLE-SECRET';\n  \n  return value;\n}\n\nfunction sanitizeObject(obj, path = '') {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj === 'string') return sanitizeValue(obj, path);\n  if (Array.isArray(obj)) return obj.map((item, i) => sanitizeObject(item, `${path}[${i}]`));\n  \n  if (typeof obj === 'object') {\n    const result = {};\n    if (obj.name && obj.value !== undefined) {\n      if (isSensitiveKeyName(obj.name)) return { ...obj, value: 'REDACTED-API-KEY' };\n      if (looksLikeSecret(obj.value)) return { ...obj, value: 'REDACTED-POSSIBLE-SECRET' };\n    }\n    const keyField = obj.key || obj.header || obj.param;\n    const valueField = obj.value || obj.content || obj.val;\n    if (keyField && valueField) {\n      if (isSensitiveKeyName(keyField) || looksLikeSecret(valueField)) {\n        return { ...obj, [Object.keys(obj).find(k => ['value', 'content', 'val'].includes(k))]: 'REDACTED' };\n      }\n    }\n    for (const [key, value] of Object.entries(obj)) {\n      const currentPath = path ? `${path}.${key}` : key;\n      if (ALWAYS_REDACT_KEYS.includes(key)) {\n        result[key] = { \"_redacted\": true };\n        continue;\n      }\n      if (isSensitiveKeyName(key) && typeof value === 'string') {\n        result[key] = 'REDACTED';\n        continue;\n      }\n      result[key] = sanitizeObject(value, currentPath);\n    }\n    return result;\n  }\n  return obj;\n}\n\nconst anonymized = sanitizeObject(sanitized);\n\nanonymized._sanitized = {\n  note: \"Sanitized automatically\",\n  timestamp: new Date().toISOString()\n};\n\nreturn [{ json: anonymized }];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2416,
          192
        ],
        "id": "REDACTED-UUID",
        "name": "New file anonymizer"
      },
      {
        "parameters": {
          "jsCode": "const oldVersion = $json.repo;\nconst newVersion = $json.new;\n\n// Klucze do ignorowania (cosmetic)\nconst IGNORE_KEYS = [\n  'position', 'id', 'webhookId', 'uuid', \n  'updatedAt', 'createdAt', 'activeVersionId',\n  'versionId', 'meta'\n];\n\n// Truncate helper\nfunction truncate(str, len) {\n  if (!str) return '';\n  str = String(str);\n  return str.length > len ? str.slice(0, len) + '...' : str;\n}\n\n// Deep compare z ignorowaniem kluczy\nfunction cleanObject(obj) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  \n  if (Array.isArray(obj)) {\n    return obj.map(item => cleanObject(item));\n  }\n  \n  const cleaned = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (IGNORE_KEYS.includes(key)) continue;\n    cleaned[key] = cleanObject(value);\n  }\n  return cleaned;\n}\n\n// Diff dla jsCode - znajd콬 dodane/usuni캧te linie\nfunction diffCode(oldCode, newCode) {\n  if (!oldCode && !newCode) return { added: [], removed: [] };\n  if (!oldCode) return { added: newCode.split('\\n').slice(0, 5), removed: [] };\n  if (!newCode) return { added: [], removed: oldCode.split('\\n').slice(0, 5) };\n  \n  const oldLines = oldCode.split('\\n').map(l => l.trim()).filter(l => l.length > 0);\n  const newLines = newCode.split('\\n').map(l => l.trim()).filter(l => l.length > 0);\n  \n  const added = newLines.filter(l => !oldLines.includes(l)).slice(0, 5);\n  const removed = oldLines.filter(l => !newLines.includes(l)).slice(0, 5);\n  \n  return { added, removed };\n}\n\n// Por칩wnaj nodes\nfunction compareNodes(oldNodes, newNodes) {\n  const changes = [];\n  \n  if (!oldNodes || !newNodes) {\n    return [{ type: 'error', detail: `Missing nodes: old=${!!oldNodes} new=${!!newNodes}` }];\n  }\n  \n  const oldByName = Object.fromEntries(oldNodes.map(n => [n.name, n]));\n  const newByName = Object.fromEntries(newNodes.map(n => [n.name, n]));\n  \n  const allNames = new Set([...Object.keys(oldByName), ...Object.keys(newByName)]);\n  \n  for (const name of allNames) {\n    if (!(name in oldByName)) {\n      const node = newByName[name];\n      changes.push({ \n        type: 'node_added', \n        node: name, \n        nodeType: node.type?.split('.').pop() || 'unknown'\n      });\n    } else if (!(name in newByName)) {\n      changes.push({ type: 'node_removed', node: name });\n    } else {\n      const oldNode = oldByName[name];\n      const newNode = newByName[name];\n      \n      const oldCode = oldNode.parameters?.jsCode;\n      const newCode = newNode.parameters?.jsCode;\n      \n      // Sprawd콬 jsCode bezpo콑rednio\n      if (oldCode !== newCode && (oldCode || newCode)) {\n        const codeDiff = diffCode(oldCode, newCode);\n        changes.push({ \n          type: 'node_modified', \n          node: name,\n          nodeType: newNode.type?.split('.').pop() || 'unknown',\n          field: 'jsCode',\n          diff: codeDiff\n        });\n        continue;\n      }\n      \n      // Sprawd콬 inne parametry\n      const oldParams = JSON.stringify(cleanObject(oldNode.parameters || {}));\n      const newParams = JSON.stringify(cleanObject(newNode.parameters || {}));\n      \n      if (oldParams !== newParams) {\n        changes.push({ \n          type: 'node_modified', \n          node: name,\n          nodeType: newNode.type?.split('.').pop() || 'unknown',\n          field: 'parameters',\n          detail: 'Config changed'\n        });\n      }\n    }\n  }\n  \n  return changes;\n}\n\n// Generuj czytelne summary\nfunction generateSummary(changes) {\n  return changes.map(c => {\n    switch(c.type) {\n      case 'node_added': \n        return `+ ADDED \"${c.node}\" (${c.nodeType})`;\n      \n      case 'node_removed': \n        return `- REMOVED \"${c.node}\"`;\n      \n      case 'node_modified': \n        let desc = `~ MODIFIED \"${c.node}\" [${c.field}]`;\n        if (c.diff) {\n          if (c.diff.added.length > 0) {\n            desc += '\\n  ADDED LINES:';\n            c.diff.added.forEach(l => desc += `\\n    + ${truncate(l, 100)}`);\n          }\n          if (c.diff.removed.length > 0) {\n            desc += '\\n  REMOVED LINES:';\n            c.diff.removed.forEach(l => desc += `\\n    - ${truncate(l, 100)}`);\n          }\n        }\n        if (c.detail) desc += `: ${c.detail}`;\n        return desc;\n      \n      case 'error':\n        return `ERROR: ${c.detail}`;\n      \n      default: \n        return `? ${c.type}`;\n    }\n  }).join('\\n\\n');\n}\n\n// === MAIN ===\nconst nodeChanges = compareNodes(oldVersion.nodes, newVersion.nodes);\n\nif (nodeChanges.length === 0) {\n  return [{ json: { \n    hasChanges: false,\n    summary: 'No significant changes detected',\n    workflowName: newVersion.name || 'unknown'\n  }}];\n}\n\nconst summary = generateSummary(nodeChanges);\n\nreturn [{ json: { \n  hasChanges: true,\n  changeCount: nodeChanges.length,\n  summary: summary,\n  workflowName: newVersion.name || 'unknown'\n}}];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2656,
          -96
        ],
        "id": "REDACTED-UUID",
        "name": "Diff"
      },
      {
        "parameters": {
          "jsCode": "// 1. POBIERANIE DANYCH (콐cie콮ka UPDATE)\n// Bierzemy \"new\" z aktualnego inputu p캧tli\nconst workflow = $('Edit Fields').first().json.new;\n\n// Je콑li z jakiego콑 powodu jest pusto, fallback do czystego jsona\n// const workflow = inputData.new || inputData;\n\nconst sanitized = JSON.parse(JSON.stringify(workflow));\n\n// ==========================================\\n// 游 CONFIGURATION\\n// ==========================================\\n\n// Nazwy kluczy kt칩re ZAWSZE redagujemy (case-insensitive)\nconst SENSITIVE_KEY_NAMES = [\n  /api[-_]?key/i, /secret/i, /token/i, /password/i, /passwd/i,\n  /bearer/i, /authorization/i, /auth/i, /credential/i,\n  /rapidapi/i, /openai/i, /anthropic/i, /deepseek/i,\n  /private[-_]?key/i, /access[-_]?key/i, /client[-_]?secret/i,\n];\n\n// Wzorce warto콑ci kt칩re ZAWSZE redagujemy\nconst SENSITIVE_VALUE_PATTERNS = [\n  { regex: /^sk-[a-zA-Z0-9]{20,}/, name: 'OpenAI' },\n  { regex: /^sk-ant-[a-zA-Z0-9-]{20,}/, name: 'Anthropic' },\n  { regex: /^xai-[a-zA-Z0-9]{20,}/, name: 'xAI' },\n  { regex: /^AIza[a-zA-Z0-9_-]{35}/, name: 'Google' },\n  { regex: /^ghp_[a-zA-Z0-9]{36}/, name: 'GitHub PAT' },\n  { regex: /^gho_[a-zA-Z0-9]{36}/, name: 'GitHub OAuth' },\n  { regex: /^xoxb-[a-zA-Z0-9-]+/, name: 'Slack Bot' },\n  { regex: /^xoxp-[a-zA-Z0-9-]+/, name: 'Slack User' },\n  { regex: /^(postgres|mysql|mongodb|redis):\\/\\/[^\\s]+/, name: 'DB Connection' },\n  { regex: /^Basic\\s+[A-Za-z0-9+/=]{10,}/, name: 'Basic Auth' },\n  { regex: /^Bearer\\s+[A-Za-z0-9._-]{10,}/, name: 'Bearer Token' },\n  { regex: /https?:\\/\\/[^:]+:[^@]+@/, name: 'URL with credentials' },\n];\n\n// Klucze do ca켹kowitego usuni캧cia\nconst ALWAYS_REDACT_KEYS = [\n  'credentials', 'webhookId', 'cachedResultUrl', 'cachedResultName',\n  'instanceId', 'projectId', 'pinData', 'meta',\n];\n\n// ==========================================\\n// 游댢 ENTROPY DETECTION\\n// ==========================================\\n\nfunction calculateEntropy(str) {\n  if (!str || str.length < 8) return 0;\n  const freq = {};\n  for (const char of str) freq[char] = (freq[char] || 0) + 1;\n  let entropy = 0;\n  const len = str.length;\n  for (const count of Object.values(freq)) {\n    const p = count / len;\n    entropy -= p * Math.log2(p);\n  }\n  return entropy;\n}\n\nfunction looksLikeSecret(value) {\n  if (typeof value !== 'string') return false;\n  if (value.length < 16 || value.length > 200) return false;\n  for (const pattern of SENSITIVE_VALUE_PATTERNS) {\n    if (pattern.regex.test(value)) return true;\n  }\n  const entropy = calculateEntropy(value);\n  const hasNumbers = /\\d/.test(value);\n  const hasLetters = /[a-zA-Z]/.test(value);\n  const noSpaces = !/\\s/.test(value);\n  const longEnough = value.length >= 20;\n  if (entropy > 4.0 && hasNumbers && hasLetters && noSpaces && longEnough) {\n    return true;\n  }\n  return false;\n}\n\nfunction isSensitiveKeyName(name) {\n  if (typeof name !== 'string') return false;\n  return SENSITIVE_KEY_NAMES.some(pattern => pattern.test(name));\n}\n\n// ==========================================\\n// 游댢 SANITIZATION\\n// ==========================================\\n\nconst redactedLog = [];\n\nfunction sanitizeValue(value, keyPath) {\n  if (typeof value !== 'string') return value;\n  const uuidRegex = /[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/gi;\n  if (uuidRegex.test(value)) return value.replace(uuidRegex, 'REDACTED-UUID');\n  \n  const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g;\n  if (emailRegex.test(value)) return value.replace(emailRegex, 'REDACTED@email.com');\n  \n  if (value.includes('docs.google.com') || value.includes('sheets.google.com')) {\n    return value.replace(/\\/d\\/[a-zA-Z0-9_-]+/, '/d/REDACTED-DOC-ID');\n  }\n  \n  if (value.includes('/webhook/')) {\n    return value.replace(/\\/webhook\\/[a-f0-9-]+/gi, '/webhook/REDACTED');\n  }\n  \n  if (looksLikeSecret(value)) return 'REDACTED-POSSIBLE-SECRET';\n  \n  return value;\n}\n\nfunction sanitizeObject(obj, path = '') {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj === 'string') return sanitizeValue(obj, path);\n  if (Array.isArray(obj)) return obj.map((item, i) => sanitizeObject(item, `${path}[${i}]`));\n  \n  if (typeof obj === 'object') {\n    const result = {};\n    if (obj.name && obj.value !== undefined) {\n      if (isSensitiveKeyName(obj.name)) return { ...obj, value: 'REDACTED-API-KEY' };\n      if (looksLikeSecret(obj.value)) return { ...obj, value: 'REDACTED-POSSIBLE-SECRET' };\n    }\n    const keyField = obj.key || obj.header || obj.param;\n    const valueField = obj.value || obj.content || obj.val;\n    if (keyField && valueField) {\n      if (isSensitiveKeyName(keyField) || looksLikeSecret(valueField)) {\n        return { ...obj, [Object.keys(obj).find(k => ['value', 'content', 'val'].includes(k))]: 'REDACTED' };\n      }\n    }\n    for (const [key, value] of Object.entries(obj)) {\n      const currentPath = path ? `${path}.${key}` : key;\n      if (ALWAYS_REDACT_KEYS.includes(key)) {\n        result[key] = { \"_redacted\": true };\n        continue;\n      }\n      if (isSensitiveKeyName(key) && typeof value === 'string') {\n        result[key] = 'REDACTED';\n        continue;\n      }\n      result[key] = sanitizeObject(value, currentPath);\n    }\n    return result;\n  }\n  return obj;\n}\n\nconst anonymized = sanitizeObject(sanitized);\n\n// Dodajemy metadane, 콮eby wiedzie캖 콮e zadzia켹a켹o\nanonymized._sanitized = {\n  note: \"Sanitized automatically\",\n  timestamp: new Date().toISOString()\n};\n\nreturn [{ json: anonymized }];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3856,
          -96
        ],
        "id": "REDACTED-UUID",
        "name": "Existing file anonymizer"
      }
    ],
    "connections": {
      "Set date": {
        "main": [
          [
            {
              "node": "Format date",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Format date": {
        "main": [
          [
            {
              "node": "Set commit date",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Set commit date": {
        "main": [
          [
            {
              "node": "List files from repository [GITHUB]",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "List files from repository [GITHUB]": {
        "main": [
          [
            {
              "node": "Combine file names [GITHUB]",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Combine file names [GITHUB]": {
        "main": [
          [
            {
              "node": "Retrieve workflows [N8N]",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Retrieve workflows [N8N]": {
        "main": [
          [
            {
              "node": "Split to single items",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Split to single items": {
        "main": [
          [
            {
              "node": "Check if file exists in repository",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check if file exists in repository": {
        "main": [
          [
            {
              "node": "Get a file",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Basic LLM Chain2",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Update file [GITHUB]": {
        "main": [
          [
            {
              "node": "Split to single items",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Upload file [GITHUB]": {
        "main": [
          [
            {
              "node": "Split to single items",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Upload file [GITHUB]1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Schedule Trigger": {
        "main": [
          [
            {
              "node": "Set date",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get a file": {
        "main": [
          [
            {
              "node": "Extract from File",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract from File": {
        "main": [
          [
            {
              "node": "Edit Fields",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Edit Fields": {
        "main": [
          [
            {
              "node": "Diff",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Basic LLM Chain": {
        "main": [
          [
            {
              "node": "Basic LLM Chain1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "DeepSeek Chat Model": {
        "ai_languageModel": [
          [
            {
              "node": "Basic LLM Chain",
              "type": "ai_languageModel",
              "index": 0
            }
          ]
        ]
      },
      "Basic LLM Chain1": {
        "main": [
          [
            {
              "node": "Existing file anonymizer",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "DeepSeek Chat Model1": {
        "ai_languageModel": [
          [
            {
              "node": "Basic LLM Chain1",
              "type": "ai_languageModel",
              "index": 0
            }
          ]
        ]
      },
      "Structured Output Parser": {
        "ai_outputParser": [
          [
            {
              "node": "Basic LLM Chain1",
              "type": "ai_outputParser",
              "index": 0
            }
          ]
        ]
      },
      "Basic LLM Chain2": {
        "main": [
          [
            {
              "node": "New file anonymizer",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "DeepSeek Chat Model2": {
        "ai_languageModel": [
          [
            {
              "node": "Basic LLM Chain2",
              "type": "ai_languageModel",
              "index": 0
            }
          ]
        ]
      },
      "Structured Output Parser1": {
        "ai_outputParser": [
          [
            {
              "node": "Basic LLM Chain2",
              "type": "ai_outputParser",
              "index": 0
            }
          ]
        ]
      },
      "If": {
        "main": [
          [
            {
              "node": "Basic LLM Chain",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Split to single items",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Upload file [GITHUB]1": {
        "main": [
          [
            {
              "node": "Split to single items",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "New file anonymizer": {
        "main": [
          [
            {
              "node": "Upload file [GITHUB]",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Diff": {
        "main": [
          [
            {
              "node": "If",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Existing file anonymizer": {
        "main": [
          [
            {
              "node": "Update file [GITHUB]",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "REDACTED",
    "name": "Version c4907afc",
    "description": "",
    "autosaved": false
  },
  "tags": [],
  "_sanitized": {
    "note": "Sanitized automatically",
    "timestamp": "2026-01-25T22:49:57.422Z"
  }
}